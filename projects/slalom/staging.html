<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jet Slalom Resurrected</title>
<script src="js/M.js"></script>
<script src="js/C.js"></script>
<script src="js/Game.js"></script>
<script>
function go_fullscreen() { const canvas_element = document.getElementById("canvas"); if(canvas_element.requestFullScreen) { canvas_element.requestFullScreen(); } else if(canvas_element.webkitRequestFullScreen) { canvas_element.webkitRequestFullScreen(); } else if(canvas_element.mozRequestFullScreen) { canvas_element.mozRequestFullScreen(); } canvas_element.focus(); }
function currentTimeMillis() { var now = new Date(); return Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(),  now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds(), now.getUTCMilliseconds()); }
// Code from Esailija at https://stackoverflow.com/questions/11866781/how-do-i-convert-an-integer-to-a-javascript-color
function c2css(num) { num >>>= 0; var b = num & 0xFF, g = (num & 0xFF00) >>> 8, r = (num & 0xFF0000) >>> 16, a = ( (num & 0xFF000000) >>> 24 ) / 255 ; return "rgba(" + [r, g, b, a].join(",") + ")"; }

var target_dt = 55;
var delay = target_dt;
var t0, t1;
var original_filter;
var paused = false;
var ship_animation = 0;

var mouse_held = false;
var mouse_x, mouse_y;
function on_mouse_down(e) {
  mouse_x = e.offsetX;
  mouse_y = e.offsetY;
  mouse_held = true;
}
function on_mouse_up(e) {
  mouse_held = false;
}
function on_mouse_move(e) {
  if(mouse_held) {
    mouse_x = e.offsetX;
    mouse_y = e.offsetY;
  }
}

var touches_x = new Map();
function on_touch_start(e) {
  e.preventDefault();
  const canvas_element = document.getElementById("canvas");
  let canvas_rect = canvas_element.getBoundingClientRect();
  for(let i = 0; i < e.changedTouches.length; i++) {
    t = e.changedTouches.item(i);
    let id = t.identifier;
    let x = t.clientX - canvas_rect.left
    touches_x.set(id, x);
  }
}
function on_touch_move(e) {
  e.preventDefault();
  const canvas_element = document.getElementById("canvas");
  let canvas_rect = canvas_element.getBoundingClientRect();
  for(let i = 0; i < e.changedTouches.length; i++) {
    t = e.changedTouches.item(i);
    let id = t.identifier;
    let x = t.clientX - canvas_rect.left
    touches_x.set(id, x);
  }
}
function on_touch_cancel(e) {
  e.preventDefault();
  for(let i = 0; i < e.changedTouches.length; i++) {
    t = e.changedTouches.item(i);
    let id = t.identifier;
    let x = t.clientX - canvas_rect.left
    touches_x.delete(id);
    if(game.title_mode) {
      game.startGame(true, x > canvas_rect.width/2);
    }
  }
}
function on_touch_end(e) {
  on_touch_cancel(e);
}

var key_left = false, key_right = false;
var key_a = false, key_d = false;
var key_j = false, key_l = false;
function on_key_down(e) {
  if(e.repeat) return;
  if(e.key == "ArrowLeft") key_left = true;
  if(e.key == "ArrowRight") key_right = true;
  if(e.key == "a") key_a = true;
  if(e.key == "d") key_d = true;
  if(e.key == "j") key_j = true;
  if(e.key == "l") key_l = true;
  if(game.title_mode) {
    if(e.key == ' ' || e.key == "Enter") game.startGame(true, false);
    if(e.key == 'w' || e.key == "ArrowUp" || e.key == 'c') game.startGame(true, true);
    if(e.key == 't') { game.prevScore = 110000; game.contNum = 100; game.startGame(true, true); } // some sort of cheat
  }
}
function on_key_up(e) {
  if(e.key == "ArrowLeft") key_left = false;
  if(e.key == "ArrowRight") key_right = false;
  if(e.key == "a") key_a = false;
  if(e.key == "d") key_d = false;
  if(e.key == "j") key_j = false;
  if(e.key == "l") key_l = false;
  if(e.key == 'p') paused = !paused;
  if(e.key == '+') target_dt+=5;
  if(e.key == '-') target_dt-=5;
}

var gamepad = {
  param_dpad_diag_count: true,
  start: false, select: false,
  south: false, north: false, west: false, east: false,
  up: false, down: false, left: false, right: false,
  left_shoulder: false, right_shoulder: false,
  l3: false, r3: false,
  left_trigger: 0, right_trigger: 0,
  lx: 0, ly: 0, rx: 0, ry: 0,
  n_start: false, n_select: false,
  n_south: false, n_north: false, n_west: false, n_east: false,
  n_up: false, n_down: false, n_left: false, n_right: false,
  n_left_shoulder: false, n_right_shoulder: false,
  n_l3: false, n_r3: false,
  available: false,
  poll: function () {
    this.n_start = this.start; this.n_select = this.select;
    this.n_south = this.south; this.n_north = this.north; this.n_west = this.west; this.n_east = this.east;
    this.n_up = this.up; this.n_down = this.down; this.n_left = this.left; this.n_right = this.right;
    this.n_left_shoulder = this.left_shoulder; this.n_right_shoulder = this.right_shoulder;
    this.n_l3 = this.l3; this.n_r3 = this.r3;
    for(const pad of navigator.getGamepads()) { if(!pad) continue;
      // see gamepad mapping at https://w3c.github.io/gamepad/#remapping
      if(pad.mapping == "standard") {
        this.available = true;
        this.south = pad.buttons[0].pressed;
        this.east = pad.buttons[1].pressed;
        this.west = pad.buttons[2].pressed;
        this.north = pad.buttons[3].pressed;
        this.left_shoulder = pad.buttons[4].pressed;
        this.right_shoulder = pad.buttons[5].pressed;
        this.left_trigger = pad.buttons[6].value; // note: I was not able to test these, I get nothing from 6 or 7 on my gamepad. omg 6,7.
        this.right_trigger = pad.buttons[7].value;
        this.select = pad.buttons[8].pressed;
        this.start = pad.buttons[9].pressed;
        this.l3 = pad.buttons[10].pressed;
        this.r3 = pad.buttons[11].pressed;
        this.up = pad.buttons[12].pressed;
        this.down = pad.buttons[13].pressed;
        this.left = pad.buttons[14].pressed;
        this.right = pad.buttons[15].pressed;
        this.lx = pad.axes[0];
        this.ly = pad.axes[1];
        this.rx = pad.axes[2];
        this.ry = pad.axes[3];
      }
    }
    this.n_start = this.start != this.n_start; this.n_select = this.select != this.n_select;
    this.n_south = this.south != this.n_south; this.n_north = this.north != this.n_north; this.n_west = this.west != this.n_west; this.n_east = this.east != this.n_east;
    this.n_up = this.up != this.n_up; this.n_down = this.down != this.n_down; this.n_left = this.left != this.n_left; this.n_right = this.right != this.n_right;
    this.n_left_shoulder = this.left_shoulder != this.n_left_shoulder; this.n_right_shoulder = this.right_shoulder != this.n_right_shoulder;
    this.n_l3 = this.l3 != this.n_l3; this.n_r3 = this.r3 != this.n_r3;
  }
};

var ship_0, ship_1;
const explosion = new Audio('res/explosion.wav');
var game = new Game();

async function app_start() {
  const canvas_element = document.getElementById("canvas");
  canvas_element.onmousedown = on_mouse_down;
  canvas_element.onmouseup = on_mouse_up;
  canvas_element.onmousemove = on_mouse_move;
  canvas_element.onkeydown = on_key_down; // the key events only work if the html canvas has a tabindex
  canvas_element.onkeyup = on_key_up;
  canvas_element.touchstart = on_touch_start;
  canvas_element.touchmove = on_touch_move;
  canvas_element.touchcancel = on_touch_cancel;
  canvas_element.touchend = on_touch_end;
  canvas_element.focus();
  const canvas = canvas_element.getContext("2d");
  original_filter = canvas.filter;

  // load assets
  ship_0 = new Image(); ship_0.src = "res/jiki.gif"; await ship_0.decode();
  ship_1 = new Image(); ship_1.src = "res/jiki2.gif"; await ship_1.decode();
  
  game.startGame(false, false);

  // start draw loop
  t0 = currentTimeMillis(); t1 = t0;
  app_draw();
}

function app_draw() {
  t0 = t1; t1 = currentTimeMillis(); let dt = t1 - t0;
  const canvas_element = document.getElementById("canvas");
  const width = canvas_element.width; const height = canvas_element.height;
  const canvas = canvas_element.getContext("2d");
  const logical_width = 320; const logical_height = 200;
  canvas.imageSmoothingEnabled = false;

  // input
  gamepad.poll(); let dead_zone = .05;
  // advanced system commands
  if(gamepad.select) {
    if(gamepad.left_shoulder && gamepad.n_left_shoulder) this.target_dt-=5;
    if(gamepad.right_shoulder && gamepad.n_right_shoulder) this.target_dt+=5;
  }
  // title command
  if(game.title_mode) {
    if((gamepad.south && gamepad.n_south) || (gamepad.north && gamepad.n_north) || (gamepad.west && gamepad.n_west) || (gamepad.east && gamepad.n_east) || (gamepad.up && gamepad.n_up)) game.startGame(true, true); // continue
    if(gamepad.select) {
      if(gamepad.start && gamepad.n_start) { game.prevScore = 110000; game.contNum = 100; game.startGame(true, true); } // some sort of cheat
    } else {
      if((gamepad.start && gamepad.n_start) || (gamepad.down && gamepad.n_down)) game.startGame(true, false); // restart
    }
  }
  // play command
  else {
    if(gamepad.start && gamepad.n_start) this.paused = !this.paused;
  }
  
  let touch_left = false, touch_right = false;
  for (const [key, value] of touches_x) {
    if(value < width/2) touch_left = true;
    if(value > width/2) touch_right = true;
  }
  let ship_left = key_a || key_j || key_left || (mouse_held && mouse_x < width / 2) || gamepad.left || gamepad.left_shoulder || gamepad.lx < -dead_zone || gamepad.rx < -dead_zone || gamepad.left_trigger > dead_zone;
  let ship_right = key_d || key_l || key_right || (mouse_held && mouse_x > width / 2) || gamepad.right || gamepad.right_shoulder || gamepad.lx > dead_zone || gamepad.rx > dead_zone || gamepad.right_trigger > dead_zone;

  if(game.title_mode && paused) paused = false;
  if(!paused) {
    game.tick(ship_left, ship_right);
  }
  
  // the svg trick to disable anti-alias of shapes does not work on an offscreen surface, so I scale the real one instead
  canvas.filter = 'url(#remove-alpha)';
  canvas.scale(4,4); draw_scene(canvas, logical_width, logical_height);
        
  // text overlay
  canvas.filter = original_filter; canvas.scale(.25,.25);
  let font_size = Math.round(height / 20);
  canvas.font = Math.round(font_size * .6) + "px serif"; sfm = canvas.measureText("font metrics");
  canvas.font = font_size + "px serif";
  canvas.fillStyle = "rgb(255 255 255)";

  // const fm = canvas.measureText(msg); width fontBoundingBoxAscent fontBoundingBoxDescent actualBoundingBoxAscent actualBoundingBoxDescent
  msg = `Your Hi-score:${game.hiscore}`; fm = canvas.measureText(msg); canvas.fillText(msg, 2*fm.fontBoundingBoxDescent/3, height - fm.fontBoundingBoxDescent);
  msg = `Period: ${target_dt}ms (${dt}ms)`; fm = canvas.measureText(msg); canvas.fillText(msg, width - 2*fm.fontBoundingBoxDescent/3 - fm.width, height - fm.fontBoundingBoxDescent);

  score = "Score:" + game.score; score_fm = canvas.measureText(score);
  penalty = "Continue penalty:" + game.contNum * 1000; penalty_fm = canvas.measureText(penalty);
  score_w = score_fm.width; penalty_w = penalty_fm.width; padding = width / 10; total_w = game.contNum > 0? score_w + padding + penalty_w : score_w; offset = (width - total_w) / 2;
  canvas.fillText(score, offset, score_fm.fontBoundingBoxAscent); offset += score_w + padding;
  if(game.contNum > 0) canvas.fillText(penalty, offset, score_fm.fontBoundingBoxAscent);
  
  if(game.title_mode) {
    line_h = fm.fontBoundingBoxAscent + fm.fontBoundingBoxDescent; small_line_h = sfm.fontBoundingBoxAscent + sfm.fontBoundingBoxDescent;
    spacing = 3, small_spacing = 2;
    n = 4, small_n = 6 + (gamepad.available? 3 : 0);
    offset = (height - ((line_h + spacing) * n + (small_line_h + small_spacing) * small_n - small_spacing)) / 2;
    offset += fm.fontBoundingBoxAscent;
    offset -= 15; // no matter what I do, it's not perfectly centered unless I hack this value, but of course this cannot survive resolution changes
    msg = "Jet Slalom Resurrected"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += line_h + spacing;
    msg = "by David Lareau in 2025"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += line_h + spacing;
    msg = "github.com/fluxrider/jetslalom"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += line_h + spacing;
    msg = "Original 1997 version by MR-C"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += line_h + spacing;
    canvas.font = Math.round(font_size * .6) + "px serif";
    msg = "-- Keyboard --"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += small_line_h + small_spacing;
    msg = "Restart(Spacebar/Enter), (C)ontinue(up/W), Chea(T)"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += small_line_h + small_spacing;
    msg = "(P)ause, Speed(+/-), Ship(Left/Right/A/D/J/L)"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += small_line_h + small_spacing;
    msg = "-- Mouse --"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += small_line_h + small_spacing;
    msg = "Ship(L/R side of screen)"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += small_line_h + small_spacing;
    msg = "Restart(L side tap), Continue(R side tap)"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += small_line_h + small_spacing;
    if(gamepad.available) {
      msg = "-- Gamepad --"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += small_line_h + small_spacing;
      msg = "Re(Start/Down), Resume(A/B/X/Y/Up), Cheat(Select+Start)"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += small_line_h + small_spacing;
      msg = "Pause(Start), Ship(Sticks/Dpad/Shoulders), Speed(Select+LB/RB)"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset); offset += small_line_h + small_spacing;
    }
  }
  if(this.paused) {
    canvas.font = font_size + "px serif";
    canvas.fillStyle = "rgb(255 0 0)";
    offset = height * (currentTimeMillis() % 10000) / 10000.0;
    msg = "Paused"; fm = canvas.measureText(msg); canvas.fillText(msg, (width - fm.width) / 2, offset);
  }

  // request another draw later
  if(dt > target_dt) { delay--; } // framerate too low, try faster
  if(dt < target_dt) { delay++; } // framerate too high, try slower
  if(delay < 1) delay = 1;
  window.setTimeout(app_draw, delay);
}

// draw game primitives
function drawFace(canvas, width, height, face) {
  let points = face.points;
  let d1 = (points[1]).x - (points[0]).x;
  let d2 = (points[1]).y - (points[0]).y;
  let d3 = (points[2]).x - (points[0]).x;
  let d4 = (points[2]).y - (points[0]).y;
  let f = Math.abs(d1 * d4 - d2 * d3) / face.maxZ;
  drawPolygon(canvas, width, height, C.drgb(C.fr(face.rgb)*f, C.fg(face.rgb)*f, C.fb(face.rgb)*f), points);
}
function drawPolygon(canvas, width, height, color, points) {
  let d1 = width / 320.0;
  let d2 = height / 200.0;
  canvas.beginPath();
  for(b = 0; b < points.length; b++) {
    let point = points[b];
    let d3 = 120.0 / (1.0 + 0.6 * point.z);
    let d4 = game.nowCos * point.x + game.nowSin * (point.y - 2.0);
    let d5 = -game.nowSin * point.x + game.nowCos * (point.y - 2.0) + 2.0;
    let x  = (d4 * d1 * d3) + width / 2;
    let y = (d5 * d2 * d3) + height / 2;
    if(b == 0) canvas.moveTo(x,y);
    else canvas.lineTo(x,y);
  }
  canvas.closePath();
  canvas.fillStyle = c2css(color);
  canvas.fill();
}
function draw_obstacle(canvas, width, height, o) {
  drawFace(canvas, width, height, o.faces[0]);
  drawFace(canvas, width, height, o.faces[1]);
}

function draw_scene(canvas, width, height) {
  canvas.fillStyle = c2css(game.rounds[game.round].getSkyRGB());
  canvas.fillRect(0, 0, width, height);
  drawPolygon(canvas, width, height, game.rounds[game.round].getGroundRGB(), game.ground_points);
  for(i = 0; i < game.obstacles.length; i++) draw_obstacle(canvas, width, height, game.obstacles[i]);
  ship_animation++;
  if(!game.title_mode) {
    let y = 24 * height / 200;
    image = this.ship_animation % 4 > 1? ship_1 : ship_0;
    if(ship_animation % 12 > 6) y = 22 * height / 200;
    if(game.score < 200) y = (12 + game.score / 20) * height / 200;
    let image_scale = width * 0.7 * 120 / 1.6 / 320; let ship_w = image_scale * 2; let ship_h = image_scale / 4;
    let ship_x = (width / 2) - ship_w/2, ship_y = height - y;
    if(game.damaged < 10) canvas.drawImage(image, ship_x, ship_y, ship_w, ship_h);
    if(game.damaged > 0) {
      if(game.damaged <= 20) {
        if(game.damaged == 1) { explosion.play(); }
        canvas.fillStyle = c2css(C.rgb(255, 255 - game.damaged * 12, 240 - game.damaged * 12));
        let i = game.damaged * 8 * width / 320;
        let j = game.damaged * 4 * height / 200;
        canvas.ellipse(width/2, 186 * height / 200, i*2, j*2, 0, 0, Math.PI*2); canvas.fill();
      }
    }
  }
}

</script>
</head>
<body onload="app_start();">
<p><button onclick="go_fullscreen();">Go Fullscreen</button>&emsp;<a href="https://github.com/fluxrider/jetslalom">Github</a></p>
<canvas id="canvas" width="1280" height="800" style="border: 3px solid black; image-rendering: pixelated;" tabindex="1"></canvas>
<!-- hack to disable anti-alias drawing: https://stackoverflow.com/questions/4261090/html5-canvas-and-anti-aliasing -->
<svg width="0" height="0" style="position:absolute;z-index:-1;"><defs><filter id="remove-alpha" x="0" y="0" width="100%" height="100%"><feComponentTransfer><feFuncA type="discrete" tableValues="0 1"></feFuncA></feComponentTransfer></filter></defs></svg>
</body>
</html>